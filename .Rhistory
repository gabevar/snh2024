vertices = fauxmesa_nodes,
# `directed` specifies whether the network is directed or undirected
directed = TRUE)
# From an adjacency matrix
triad_igraph <- graph_from_adjacency_matrix(
# `adjmatrix` specifies the adjacency matrix
adjmatrix = triad,
# `mode` specifies whether `igraph` should treat the matrix as directed or undirected
mode = "directed")
# Indegree
faux_indegree <- degree(fauxmesa_igraph, mode = "in")
head(faux_indegree)
# Outdegree
faux_outdegree <- degree(fauxmesa_igraph, mode = "out")
head(faux_outdegree)
# Total degree
faux_total_degree <- degree(fauxmesa_igraph, mode = "total")
head(faux_total_degree)
faux_betweenness <- betweenness(fauxmesa_igraph, directed = TRUE)
head(faux_betweenness)
faux_closeness <- closeness(fauxmesa_igraph)
head(faux_closeness)
faux_eigen <- eigen_centrality(fauxmesa_igraph, directed = FALSE)$vector
# Will return a list, the node-level centrality measures are in the `vector` item in this list
# Here we tread as undirected because directed edges lead to issues in calculation
head(faux_eigen)
centrality_df <- data.frame(indegree = faux_indegree,
outdegree = faux_outdegree,
total_degree = faux_total_degree,
betweenness = faux_betweenness,
eigen = faux_eigen)
# Get correlation
cor(centrality_df$indegree, centrality_df$eigen)
faux_density <- edge_density(fauxmesa_igraph)
faux_density
faux_clust <- transitivity(fauxmesa_igraph, type = "global")
faux_clust
plot(# `igraph` object
fauxmesa_igraph,
# Removing vertex labels to keep things legible for large networks
vertex.label = NA,
# Change node size
vertex.size = 4,
# Change edge arrow size
edge.arrow.size = .1,
# Color nodes by a stored attribute in the `igraph` object
vertex.color = as.factor(V(fauxmesa_igraph)$grade))
nw_fauxmesa <- netwrite(nodelist = fauxmesa_nodes,
node_id = "id",
i_elements = fauxmesa_edges$from,
j_elements = fauxmesa_edges$to,
directed = TRUE,
net_name = "faux_mesa")
list2env(nw_fauxmesa, .GlobalEnv)
system_measure_plot
head(system_level_measures)
faux_mesa
head(edgelist)
head(node_measures)
node_measure_plot
nw_triad <- netwrite(data_type = "adjacency_matrix",
adjacency_matrix = triad,
directed = TRUE,
net_name = "triad_igraph")
list2env(nw_triad, .GlobalEnv)
head(florentine_edges)
nw_flor <- netwrite(nodelist = florentine_nodes,
node_id = "id",
i_elements = florentine_edges$source,
j_elements = florentine_edges$target,
type = florentine_edges$type,
directed = FALSE,
net_name = "florentine")
list2env(nw_flor, .GlobalEnv)
head(edgelist$business)
head(edgelist$summary_graph)
node_measures %>%
dplyr::select(id, total_degree, marriage_total_degree, business_total_degree) %>%
head()
head(system_level_measures)
par(mfrow = c(1, 2), mar = c(1, 1, 1, 1))
# Create a consistent layout for both plots
flor_layout <- igraph::layout.fruchterman.reingold(igraph_list$marriage)
plot(igraph_list$marriage, vertex.label = NA, vertex.size = 4, edge.arrow.size = 0.2,
vertex.color = "gray", main = "Marriage Network", layout = flor_layout)
plot(igraph_list$business, vertex.label = NA, vertex.size = 4, edge.arrow.size = 0.2,
vertex.color = "red", main = "Business Network", layout = flor_layout)
ideanetViz()
renv:: settings$snapshot. type("all")
renv::settings$snapshot.type("all")
renv::snapshot()
library(dplyr)
library(ideanet)
library(igraph)
head(fauxmesa_nodes)
triad
head(ngq_egos)
head(ngq_alters)
head(ngq_aa)
# From an edgelist
fauxmesa_igraph <- graph_from_data_frame(
# The `d` argument here specifies the data frame containing the edgelist
d = fauxmesa_edges,
# `vertices` specifies the nodelist data frame (if applicable)
vertices = fauxmesa_nodes,
# `directed` specifies whether the network is directed or undirected
directed = TRUE)
# From an adjacency matrix
triad_igraph <- graph_from_adjacency_matrix(
# `adjmatrix` specifies the adjacency matrix
adjmatrix = triad,
# `mode` specifies whether `igraph` should treat the matrix as directed or undirected
mode = "directed")
# Indegree
faux_indegree <- degree(fauxmesa_igraph, mode = "in")
head(faux_indegree)
# Outdegree
faux_outdegree <- degree(fauxmesa_igraph, mode = "out")
head(faux_outdegree)
# Total degree
faux_total_degree <- degree(fauxmesa_igraph, mode = "total")
head(faux_total_degree)
faux_betweenness <- betweenness(fauxmesa_igraph, directed = TRUE)
head(faux_betweenness)
faux_closeness <- closeness(fauxmesa_igraph)
head(faux_closeness)
faux_eigen <- eigen_centrality(fauxmesa_igraph, directed = FALSE)$vector
# Will return a list, the node-level centrality measures are in the `vector` item in this list
# Here we tread as undirected because directed edges lead to issues in calculation
head(faux_eigen)
centrality_df <- data.frame(indegree = faux_indegree,
outdegree = faux_outdegree,
total_degree = faux_total_degree,
betweenness = faux_betweenness,
eigen = faux_eigen)
# Get correlation
cor(centrality_df$indegree, centrality_df$eigen)
faux_density <- edge_density(fauxmesa_igraph)
faux_density
faux_clust <- transitivity(fauxmesa_igraph, type = "global")
faux_clust
plot(# `igraph` object
fauxmesa_igraph,
# Removing vertex labels to keep things legible for large networks
vertex.label = NA,
# Change node size
vertex.size = 4,
# Change edge arrow size
edge.arrow.size = .1,
# Color nodes by a stored attribute in the `igraph` object
vertex.color = as.factor(V(fauxmesa_igraph)$grade))
nw_fauxmesa <- netwrite(nodelist = fauxmesa_nodes,
node_id = "id",
i_elements = fauxmesa_edges$from,
j_elements = fauxmesa_edges$to,
directed = TRUE,
net_name = "faux_mesa")
list2env(nw_fauxmesa, .GlobalEnv)
system_measure_plot
head(system_level_measures)
faux_mesa
head(edgelist)
head(node_measures)
node_measure_plot
nw_triad <- netwrite(data_type = "adjacency_matrix",
adjacency_matrix = triad,
directed = TRUE,
net_name = "triad_igraph")
list2env(nw_triad, .GlobalEnv)
head(florentine_edges)
nw_flor <- netwrite(nodelist = florentine_nodes,
node_id = "id",
i_elements = florentine_edges$source,
j_elements = florentine_edges$target,
type = florentine_edges$type,
directed = FALSE,
net_name = "florentine")
list2env(nw_flor, .GlobalEnv)
head(edgelist$business)
head(edgelist$summary_graph)
node_measures %>%
dplyr::select(id, total_degree, marriage_total_degree, business_total_degree) %>%
head()
head(system_level_measures)
par(mfrow = c(1, 2), mar = c(1, 1, 1, 1))
# Create a consistent layout for both plots
flor_layout <- igraph::layout.fruchterman.reingold(igraph_list$marriage)
plot(igraph_list$marriage, vertex.label = NA, vertex.size = 4, edge.arrow.size = 0.2,
vertex.color = "gray", main = "Marriage Network", layout = flor_layout)
plot(igraph_list$business, vertex.label = NA, vertex.size = 4, edge.arrow.size = 0.2,
vertex.color = "red", main = "Business Network", layout = flor_layout)
ideanetViz()
renv::snapshot()
library(dplyr)
library(ideanet)
library(igraph)
head(fauxmesa_nodes)
triad
head(ngq_egos)
head(ngq_alters)
head(ngq_aa)
# From an edgelist
fauxmesa_igraph <- graph_from_data_frame(
# The `d` argument here specifies the data frame containing the edgelist
d = fauxmesa_edges,
# `vertices` specifies the nodelist data frame (if applicable)
vertices = fauxmesa_nodes,
# `directed` specifies whether the network is directed or undirected
directed = TRUE)
# From an adjacency matrix
triad_igraph <- graph_from_adjacency_matrix(
# `adjmatrix` specifies the adjacency matrix
adjmatrix = triad,
# `mode` specifies whether `igraph` should treat the matrix as directed or undirected
mode = "directed")
# Indegree
faux_indegree <- degree(fauxmesa_igraph, mode = "in")
head(faux_indegree)
# Outdegree
faux_outdegree <- degree(fauxmesa_igraph, mode = "out")
head(faux_outdegree)
# Total degree
faux_total_degree <- degree(fauxmesa_igraph, mode = "total")
head(faux_total_degree)
faux_betweenness <- betweenness(fauxmesa_igraph, directed = TRUE)
head(faux_betweenness)
faux_closeness <- closeness(fauxmesa_igraph)
head(faux_closeness)
faux_eigen <- eigen_centrality(fauxmesa_igraph, directed = FALSE)$vector
# Will return a list, the node-level centrality measures are in the `vector` item in this list
# Here we tread as undirected because directed edges lead to issues in calculation
head(faux_eigen)
centrality_df <- data.frame(indegree = faux_indegree,
outdegree = faux_outdegree,
total_degree = faux_total_degree,
betweenness = faux_betweenness,
eigen = faux_eigen)
# Get correlation
cor(centrality_df$indegree, centrality_df$eigen)
faux_density <- edge_density(fauxmesa_igraph)
faux_density
faux_clust <- transitivity(fauxmesa_igraph, type = "global")
faux_clust
plot(# `igraph` object
fauxmesa_igraph,
# Removing vertex labels to keep things legible for large networks
vertex.label = NA,
# Change node size
vertex.size = 4,
# Change edge arrow size
edge.arrow.size = .1,
# Color nodes by a stored attribute in the `igraph` object
vertex.color = as.factor(V(fauxmesa_igraph)$grade))
nw_fauxmesa <- netwrite(nodelist = fauxmesa_nodes,
node_id = "id",
i_elements = fauxmesa_edges$from,
j_elements = fauxmesa_edges$to,
directed = TRUE,
net_name = "faux_mesa")
list2env(nw_fauxmesa, .GlobalEnv)
system_measure_plot
head(system_level_measures)
faux_mesa
head(edgelist)
head(node_measures)
node_measure_plot
nw_triad <- netwrite(data_type = "adjacency_matrix",
adjacency_matrix = triad,
directed = TRUE,
net_name = "triad_igraph")
list2env(nw_triad, .GlobalEnv)
head(florentine_edges)
nw_flor <- netwrite(nodelist = florentine_nodes,
node_id = "id",
i_elements = florentine_edges$source,
j_elements = florentine_edges$target,
type = florentine_edges$type,
directed = FALSE,
net_name = "florentine")
list2env(nw_flor, .GlobalEnv)
head(edgelist$business)
head(edgelist$summary_graph)
node_measures %>%
dplyr::select(id, total_degree, marriage_total_degree, business_total_degree) %>%
head()
head(system_level_measures)
par(mfrow = c(1, 2), mar = c(1, 1, 1, 1))
# Create a consistent layout for both plots
flor_layout <- igraph::layout.fruchterman.reingold(igraph_list$marriage)
plot(igraph_list$marriage, vertex.label = NA, vertex.size = 4, edge.arrow.size = 0.2,
vertex.color = "gray", main = "Marriage Network", layout = flor_layout)
plot(igraph_list$business, vertex.label = NA, vertex.size = 4, edge.arrow.size = 0.2,
vertex.color = "red", main = "Business Network", layout = flor_layout)
ideanetViz()
library(dplyr)
library(ideanet)
library(igraph)
head(fauxmesa_nodes)
triad
head(ngq_egos)
head(ngq_alters)
head(ngq_aa)
# From an edgelist
fauxmesa_igraph <- graph_from_data_frame(
# The `d` argument here specifies the data frame containing the edgelist
d = fauxmesa_edges,
# `vertices` specifies the nodelist data frame (if applicable)
vertices = fauxmesa_nodes,
# `directed` specifies whether the network is directed or undirected
directed = TRUE)
# From an adjacency matrix
triad_igraph <- graph_from_adjacency_matrix(
# `adjmatrix` specifies the adjacency matrix
adjmatrix = triad,
# `mode` specifies whether `igraph` should treat the matrix as directed or undirected
mode = "directed")
# Indegree
faux_indegree <- degree(fauxmesa_igraph, mode = "in")
head(faux_indegree)
# Outdegree
faux_outdegree <- degree(fauxmesa_igraph, mode = "out")
head(faux_outdegree)
# Total degree
faux_total_degree <- degree(fauxmesa_igraph, mode = "total")
head(faux_total_degree)
faux_betweenness <- betweenness(fauxmesa_igraph, directed = TRUE)
head(faux_betweenness)
faux_closeness <- closeness(fauxmesa_igraph)
head(faux_closeness)
faux_eigen <- eigen_centrality(fauxmesa_igraph, directed = FALSE)$vector
# Will return a list, the node-level centrality measures are in the `vector` item in this list
# Here we tread as undirected because directed edges lead to issues in calculation
head(faux_eigen)
centrality_df <- data.frame(indegree = faux_indegree,
outdegree = faux_outdegree,
total_degree = faux_total_degree,
betweenness = faux_betweenness,
eigen = faux_eigen)
# Get correlation
cor(centrality_df$indegree, centrality_df$eigen)
faux_density <- edge_density(fauxmesa_igraph)
faux_density
faux_clust <- transitivity(fauxmesa_igraph, type = "global")
faux_clust
plot(# `igraph` object
fauxmesa_igraph,
# Removing vertex labels to keep things legible for large networks
vertex.label = NA,
# Change node size
vertex.size = 4,
# Change edge arrow size
edge.arrow.size = .1,
# Color nodes by a stored attribute in the `igraph` object
vertex.color = as.factor(V(fauxmesa_igraph)$grade))
nw_fauxmesa <- netwrite(nodelist = fauxmesa_nodes,
node_id = "id",
i_elements = fauxmesa_edges$from,
j_elements = fauxmesa_edges$to,
directed = TRUE,
net_name = "faux_mesa")
list2env(nw_fauxmesa, .GlobalEnv)
system_measure_plot
head(system_level_measures)
faux_mesa
head(edgelist)
head(node_measures)
node_measure_plot
nw_triad <- netwrite(data_type = "adjacency_matrix",
adjacency_matrix = triad,
directed = TRUE,
net_name = "triad_igraph")
list2env(nw_triad, .GlobalEnv)
head(florentine_edges)
nw_flor <- netwrite(nodelist = florentine_nodes,
node_id = "id",
i_elements = florentine_edges$source,
j_elements = florentine_edges$target,
type = florentine_edges$type,
directed = FALSE,
net_name = "florentine")
list2env(nw_flor, .GlobalEnv)
head(edgelist$business)
head(edgelist$summary_graph)
node_measures %>%
dplyr::select(id, total_degree, marriage_total_degree, business_total_degree) %>%
head()
head(system_level_measures)
par(mfrow = c(1, 2), mar = c(1, 1, 1, 1))
# Create a consistent layout for both plots
flor_layout <- igraph::layout.fruchterman.reingold(igraph_list$marriage)
plot(igraph_list$marriage, vertex.label = NA, vertex.size = 4, edge.arrow.size = 0.2,
vertex.color = "gray", main = "Marriage Network", layout = flor_layout)
plot(igraph_list$business, vertex.label = NA, vertex.size = 4, edge.arrow.size = 0.2,
vertex.color = "red", main = "Business Network", layout = flor_layout)
ideanetViz()
library(dplyr)
library(ideanet)
# library(igraph)
head(fauxmesa_nodes)
triad
head(ngq_egos)
head(ngq_alters)
head(ngq_aa)
# From an edgelist
fauxmesa_igraph <- graph_from_data_frame(
# The `d` argument here specifies the data frame containing the edgelist
d = fauxmesa_edges,
# `vertices` specifies the nodelist data frame (if applicable)
vertices = fauxmesa_nodes,
# `directed` specifies whether the network is directed or undirected
directed = TRUE)
library(dplyr)
library(igraph)
library(ideanet)
head(fauxmesa_nodes)
triad
head(ngq_egos)
head(ngq_alters)
head(ngq_aa)
# From an edgelist
fauxmesa_igraph <- graph_from_data_frame(
# The `d` argument here specifies the data frame containing the edgelist
d = fauxmesa_edges,
# `vertices` specifies the nodelist data frame (if applicable)
vertices = fauxmesa_nodes,
# `directed` specifies whether the network is directed or undirected
directed = TRUE)
# From an adjacency matrix
triad_igraph <- graph_from_adjacency_matrix(
# `adjmatrix` specifies the adjacency matrix
adjmatrix = triad,
# `mode` specifies whether `igraph` should treat the matrix as directed or undirected
mode = "directed")
# Indegree
faux_indegree <- degree(fauxmesa_igraph, mode = "in")
head(faux_indegree)
# Outdegree
faux_outdegree <- degree(fauxmesa_igraph, mode = "out")
head(faux_outdegree)
# Total degree
faux_total_degree <- degree(fauxmesa_igraph, mode = "total")
head(faux_total_degree)
faux_betweenness <- betweenness(fauxmesa_igraph, directed = TRUE)
head(faux_betweenness)
faux_closeness <- closeness(fauxmesa_igraph)
head(faux_closeness)
faux_eigen <- eigen_centrality(fauxmesa_igraph, directed = FALSE)$vector
# Will return a list, the node-level centrality measures are in the `vector` item in this list
# Here we tread as undirected because directed edges lead to issues in calculation
head(faux_eigen)
centrality_df <- data.frame(indegree = faux_indegree,
outdegree = faux_outdegree,
total_degree = faux_total_degree,
betweenness = faux_betweenness,
eigen = faux_eigen)
# Get correlation
cor(centrality_df$indegree, centrality_df$eigen)
faux_density <- edge_density(fauxmesa_igraph)
faux_density
faux_clust <- transitivity(fauxmesa_igraph, type = "global")
faux_clust
plot(# `igraph` object
fauxmesa_igraph,
# Removing vertex labels to keep things legible for large networks
vertex.label = NA,
# Change node size
vertex.size = 4,
# Change edge arrow size
edge.arrow.size = .1,
# Color nodes by a stored attribute in the `igraph` object
vertex.color = as.factor(V(fauxmesa_igraph)$grade))
nw_fauxmesa <- netwrite(nodelist = fauxmesa_nodes,
node_id = "id",
i_elements = fauxmesa_edges$from,
j_elements = fauxmesa_edges$to,
directed = TRUE,
net_name = "faux_mesa")
list2env(nw_fauxmesa, .GlobalEnv)
system_measure_plot
head(system_level_measures)
faux_mesa
head(edgelist)
head(node_measures)
node_measure_plot
nw_triad <- netwrite(data_type = "adjacency_matrix",
adjacency_matrix = triad,
directed = TRUE,
net_name = "triad_igraph")
list2env(nw_triad, .GlobalEnv)
head(florentine_edges)
nw_flor <- netwrite(nodelist = florentine_nodes,
node_id = "id",
i_elements = florentine_edges$source,
j_elements = florentine_edges$target,
type = florentine_edges$type,
directed = FALSE,
net_name = "florentine")
list2env(nw_flor, .GlobalEnv)
head(edgelist$business)
head(edgelist$summary_graph)
node_measures %>%
dplyr::select(id, total_degree, marriage_total_degree, business_total_degree) %>%
head()
head(system_level_measures)
par(mfrow = c(1, 2), mar = c(1, 1, 1, 1))
# Create a consistent layout for both plots
flor_layout <- igraph::layout.fruchterman.reingold(igraph_list$marriage)
plot(igraph_list$marriage, vertex.label = NA, vertex.size = 4, edge.arrow.size = 0.2,
vertex.color = "gray", main = "Marriage Network", layout = flor_layout)
plot(igraph_list$business, vertex.label = NA, vertex.size = 4, edge.arrow.size = 0.2,
vertex.color = "red", main = "Business Network", layout = flor_layout)
ideanetViz()
